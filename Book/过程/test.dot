digraph graphname {

    准备代码片段和运行代码的环境 -> 解析S表达式
    解析S表达式 ->得到操作符号和操作数-> 判断操作符类型  
    用当前环境计算每个参数值 -> 用当前环境计算每个参数值
    判断操作符类型 -> 基本算术符号 -> 用当前环境计算每个参数值 -> 用算术符号作用于每个参数得到一个基本元素符号->返回基本元素符号
    判断操作符类型 -> 获取变量值 -> 在环境中找到变量名对应的值 -> 变量值作为一个基本元素符号->返回基本元素符号
    判断操作符类型 -> 特殊操作绑定 -> 在环境中计算变量名的值-> 把变量名对应值扩展到环境中 -> 构成新环境和绑定区域代码
    构成新环境和绑定区域代码 -> 递归调用计算新环境中的代码值 -> 返回基本元素符号
    判断操作符类型 -> 定义匿名函数 -> 克隆当前环境作为函数的环境-> 包装当前的函数和当前运行环境为一个闭包元素符号 -> 闭包元素符号-> 返回基本元素符号
    判断操作符类型 -> 调用自定义函数 ->以当前环境计算当前的函数值->得到一个闭包元素符号 -> 以当前环境计算当前的参数值    
    以当前环境计算当前的参数值 -> 把参数扩展进闭包元中的函数定义环境 ->用闭包中的函数和闭包中的运行环境->递归调用计算新环境中的代码值
    以当前环境计算当前的参数值 -> 以当前环境计算当前的参数值
    以当前环境计算当前的函数值 -> 以当前环境计算当前的函数值
    判断操作符类型 -> 数字元素 ->返回基本元素符号
    返回基本元素符号 -> 程序结束
    递归调用计算新环境中的代码值 -> 递归调用计算新环境中的代码值
   
}
