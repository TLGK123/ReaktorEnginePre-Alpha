digraph graphname {

    准备代码片段和运行代码的环境 ->读一段代码 -> 解析S表达式
    解析S表达式 -> 得到一组基本元素序列 ->设置序列访问index为1 -> 访问第index个元素符号
    访问第index个元素符号 -> 判断符号是为右边结束符吗
    判断符号是为右边结束符吗 -> 不是右边结束符
    判断符号是为右边结束符吗 -> 是右边结束符
    不是右边结束符 -> 将单个元素符号压入代码堆栈 -> index序号加1
    index序号加1 -> 超出序列个数
    index序号加1 -> 不是最后一个字符
    不是最后一个字符 -> 访问第index个元素符号
    是右边结束符-> 从代码栈取出一个元素
    从代码栈取出一个元素 -> 判断是不是左边终结符
    判断是不是左边终结符 -> 是左边终结符
    判断是不是左边终结符 -> 非左边终结符
    是左边终结符 -> 取出数据缓存区栈顶元素符号 ->此栈顶元素一定是操作符，其余的是操作数据
    此栈顶元素一定是操作符，其余的是操作数据 -> 将操作符应用于操作数
    非左边终结符 -> 压入数据缓存区堆栈
    计算的结果为一个基本元素符号 -> 将单个元素符号压入代码堆栈
    压入数据缓存区堆栈 -> 从代码栈取出一个元素
    超出序列个数 -> 返回代码栈的数据 -> 程序结束
    将操作符应用于操作数 -> 判断操作符类型 
    判断操作符类型 -> 基本算术符号 -> 直接计算结果 -> 计算的结果为一个基本元素符号
    判断操作符类型 -> 获取变量值 -> 在环境中找到变量名对应的值 -> 将单个元素符号压入代码堆栈
    判断操作符类型 -> 特殊操作赋值 -> 在环境中绑定变量名和值
    判断操作符类型 -> 定义匿名函数 -> 克隆当前环境作为函数的环境-> 包装当前的函数和当前运行环境为一个闭包元素符号 -> 闭包元素符号-> 将单个元素符号压入代码堆栈
    判断操作符类型 -> 调用自定义函数 ->以当前环境计算当前的函数值->得到一个闭包元素符号 -> 以当前环境计算当前的参数值 
    以当前环境计算当前的参数值 -> 把参数扩展进闭包元素符号中的函数定义环境 ->用闭包中的函数当作代码片段，用闭包中扩展后的环境当作运行环境->准备代码片段和运行代码的环境
   
}
