digraph graphname {

    准备代码片段和运行代码的环境 -> 解析S表达式
    解析S表达式 ->得到操作符号和操作数-> 判断操作符类型  
    访问第index个元素符号 -> 判断符号是为右边结束符吗
    判断符号是为右边结束符吗 -> 不是右边结束符
    判断符号是为右边结束符吗 -> 是右边结束符
    不是右边结束符 -> 将单个元素符号压入代码堆栈 -> index序号加1


    不是最后一个字符 -> 访问第index个元素符号
    是右边结束符-> 从代码栈取出一个元素
    从代码栈取出一个元素 -> 判断是不是左边终结符
    判断是不是左边终结符 -> 是左边终结符
    判断是不是左边终结符 -> 非左边终结符
    是左边终结符 -> 取出数据缓存区栈顶元素符号 ->此栈顶元素一定是操作符，其余的是操作数据
    此栈顶元素一定是操作符，其余的是操作数据 -> 将操作符应用于操作数
    非左边终结符 -> 压入数据缓存区堆栈
    计算的结果为一个基本元素符号 -> 将单个元素符号压入代码堆栈
    压入数据缓存区堆栈 -> 从代码栈取出一个元素
    超出序列个数 -> 返回代码栈的数据 -> 程序结束
    将操作符应用于操作数 -> 判断操作符类型 
    判断操作符类型 -> 基本算术符号 -> 用当前环境计算每个参数值 ->用算术符号作用于每个参数得到一个基本元素符号->返回基本元素符号
    判断操作符类型 -> 获取变量值 -> 在环境中找到变量名对应的值 -> 变量值作为一个基本元素符号->返回基本元素符号
    判断操作符类型 -> 特殊操作绑定 -> 在环境中计算变量名的值-> 把变量名对应值扩展到环境中 -> 构成新环境和绑定区域代码
    构成新环境和绑定区域代码 -> 递归调用计算新环境中的代码值 -> 返回基本元素符号
    判断操作符类型 -> 定义匿名函数 -> 克隆当前环境作为函数的环境-> 包装当前的函数和当前运行环境为一个闭包元素符号 -> 闭包元素符号-> 返回基本元素符号
    判断操作符类型 -> 调用自定义函数 ->以当前环境计算当前的函数值->得到一个闭包元素符号 -> 以当前环境计算当前的参数值    
    以当前环境计算当前的参数值 -> 把参数扩展进闭包元中的函数定义环境 ->用闭包中的函数和闭包中的运行环境->递归调用计算新环境中的代码值
    判断操作符类型 -> 数字元素 ->返回基本元素符号
    返回基本元素符号 -> 程序结束
   
}
